#!/usr/bin/env python

# this program takes molecular substructures as generated by molecularSubstructureFromAttributes.py
# and filters the bits from the set of drugs provided in order to have a workable number of features.

# an example of the in data:
# CHEMBL57053 subSmiles   c(c(O)c)cc_2,c(cc)(Cl)cc,c(cc)c(Cl)c_2,c(O)(cc)cc
# CHEMBL57055 subSmiles   C([N+](C)(C)C)C(O)c,c(C(C)O)(cc)cc,c(cc)(O)c(O)c,c(c(C)c)cc....

from __future__ import print_function
import sys, os, django, time
import statistics as stats
from collections import defaultdict
from optparse import OptionParser
sys.path.insert(1,"../../web1")
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "web1.settings")
django.setup()
from algorithms.exit_codes import ExitCoder

def message(*objs):
    print(*objs, file=sys.stderr)

def warning(*objs):
    print("WARNING: ", *objs, file=sys.stderr)

def verboseOut(*objs):
    if options.verbose:
        print(*objs, file=sys.stderr)

def useage(*objs):
    print("USEAGE: ", *objs, file=sys.stderr)

def printOut(*objs):
    print(*objs, file=sys.stdout)

def readFileIn(inputFile):
    subMolsInDrugs = defaultdict(dict)
    allDrugs = []
    with open(inputFile, 'r') as f:
        for line in f:
            fields = line.rstrip().split("\t")
            drugID = convertDrugId(fields[0])
            allDrugs.append(drugID)
            allSmiles = [l.split("_") for l in fields[2].split(",")]
            for sublist in allSmiles:
                if len(sublist) > 1:
                    subMolsInDrugs[sublist[0]][drugID] = int(sublist[1])
                else:
                     subMolsInDrugs[sublist[0]][drugID] = 1
    return subMolsInDrugs, allDrugs

# currently we're not doing this, but eventually we may want to conver these IDs from ChEMBL to something else
def convertDrugId(rawDrugId):
    return rawDrugId

def summaryStats(l):
    import numpy as np
    verboseOut({'Minimum': min(l)
            , 'FirstQ': np.percentile(l, 25)
            , 'Median': stats.median(l)
            , 'ThirdQ': np.percentile(l, 75)
            , 'Maximum': max(l)})

if __name__=='__main__':
    #=================================================
    # Read in the arguments/define options
    #=================================================
    
    exitCoder = ExitCoder()
    
    opts = OptionParser()
    
    #usage = "usage: %prog [options] [input] Extract all molecular substructures from smiles codes in provided file, using a nested filtering: minimum protion, minimum variance, maximal average mutual information"
    usage = "usage: %prog [options] [input] Extract all molecular substructures from smiles codes in provided file, using a nested filtering: minimum protion, minimum variance"
    
    opts = OptionParser(usage=usage)
    
    opts.add_option("-i", '--attribute_file', help="subSmiles attributes file")
    opts.add_option("-o", '--outputFile', help="File to write output to. Default: attribute file appended with: _filteredSubSmiles.csv")
    opts.add_option("-p", '--minPortion', type=float, default=0.002, help="Minimum portion of drugs which must have a substructure. DEFAULT=0.002")
    opts.add_option("-v", '--minVariance', type=float, default=0.005, help="Minimum variance of submolecule counts for a substructure. DEFAULT=0.005")
    opts.add_option('--verbose', action="store_true")
    #opts.add_option("-m", '--maxMI', default = 0.002, help="Maximal average mutual information score with any other substructure ")
    options, arguments = opts.parse_args()
    
    # return usage information if no argvs given
    
    if not options.attribute_file:
        opts.print_help()
        sys.exit(exitCoder.encode('usageError'))
    
    if not options.outputFile:
        options.outputFile = options.attribute_file + "_filteredSubSmiles.csv"
    
    #========================================================================================
    # Main
    #========================================================================================
    
    # the resulting dataframe is drugs (rows) by sub molecule counts (columns, all 1, if there was not count)
    subMolDrugDoD, allDrugs = readFileIn(options.attribute_file)
    # This may not be useful, but I'm storing some stats on these for now
    allVars = {}
    allPortions = {}
    toReport = [[drug] for drug in allDrugs]
    reportedBits = []
    
    t = time.time()
    for subMol in subMolDrugDoD.keys():
        observedCounts = [ subMolDrugDoD[subMol][drug] for drug in subMolDrugDoD[subMol].keys()]
        allPortions[subMol] = float(len(observedCounts))/len(allDrugs)
        if allPortions[subMol] < options.minPortion:
            continue
        allVars[subMol] = stats.variance([item for sublist in [observedCounts, [0] * (len(allDrugs) - len(observedCounts))] for item in sublist])
        if allVars[subMol] >= options.minVariance:
            for i in xrange(len(allDrugs)):
                if allDrugs[i] in subMolDrugDoD[subMol].keys():
                    toReport[i].append(str(subMolDrugDoD[subMol][allDrugs[i]]))
                else:
                    toReport[i].append("0")
            reportedBits.append(subMol)
    
    verboseOut("variance analysis took: ", time.time() -t, "seconds")
    
    with open(options.outputFile, 'w') as f:
        f.write(",".join([item for sublist in [['drug_id'], reportedBits] for item in sublist]) + "\n")
        f.write("\n".join([",".join(l) for l in toReport]) + "\n")
        
    summaryStats(allPortions.values())
    summaryStats(allVars.values())

