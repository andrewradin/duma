
from django.urls import reverse
from django.utils.safestring import mark_safe
from dtk.table import Table


class ColumnGroup:
    def __init__(self):
        pass

    def resolve_to_columns(self, rows):
        pass



class SingleColumn(ColumnGroup):
    def __init__(self, name):
        self.name = name

    def _extract_all(self, rows):
        for row in rows:
            yield row.id, self._extract(row)

    def resolve_to_columns(self, rows):
        rowdata = dict(self._extract_all(rows))
        return [Table.Column(self.name, extract=lambda x: rowdata[x.id])]


class DrugAttr(SingleColumn):
    def _extract(self, wsa):
        return getattr(wsa.agent, self.name, 'N/A')

class WsaAttr(SingleColumn):
    def _extract(self, wsa):
        return getattr(wsa, self.name, 'N/A')


class Checkbox(SingleColumn):
    def _extract(self, wsa):
        return mark_safe(f'<input name="check_{wsa.id}" type="checkbox" />')

class EditableHitScoreValue:
    AUTO_PREFIX = 'Autogenerated'
    def __init__(self, ws, scoretype, *args, **kwargs):
        self.ws = ws
        from moldata.models import HitScoreValue, ScoreTypes, ScoreTypeData
        from dtk.html import glyph_icon
        self.scoretype = scoretype
        label = ScoreTypes.get('label', scoretype)
        self.label = label
        ScoreClass = ScoreTypeData.from_scoretype(scoretype)
        self.ScoreClass = ScoreClass
        weight = ScoreClass.weight
        help_text = ScoreClass.scoring_help

        weight_text = f"Portion of overall score: {weight*100:.0f}%" if weight else ""
        scoring = f"<span class='scoring_guide'>Scoring:\n{help_text}\n{weight_text}</span>"

        from dtk.html import popover, glyph_icon
        icon = glyph_icon('question-sign')
        scoring_details = popover(icon, scoring)
        self.name = mark_safe(f"{label} {scoring_details}")

        self._args = args
        self._kwargs = kwargs

    def get_values(self, wsas):
        from moldata.models import HitScoreValue, ScoreTypes, ScoreTypeData
        objs = HitScoreValue.objects.filter(wsa__in=wsas, scoretype=self.scoretype)
        return {obj.wsa_id: obj for obj in objs}

    def make_wsa_extractor(self, wsas):
        autos = self.ScoreClass.autogenerate(self.ws, wsas, *self._args, **self._kwargs)
        values = self.get_values(wsas)

        def _wsa_extract(wsa):
            details = ''
            if wsa.id in values:
                note = values[wsa.id].note
                score = values[wsa.id].value
            elif wsa.id in autos:
                score = autos[wsa.id][0]
                note = f'{self.AUTO_PREFIX} - {autos[wsa.id][1]}'
            else:
                note = ''
                score = ''

            if wsa.id in autos:
                detail_data = autos[wsa.id][2]
            else:
                detail_data = []

            if self.ScoreClass.weight == 0:
                score = None

            if isinstance(score, float):
                # Clamp the score, just in case some bad values got through.
                score = min(max(score, 0.0), 4.0)
            return note, score, detail_data
        return _wsa_extract


    def resolve_to_column(self, extractor):
        def _extract(wsa):
            note, score, detail_data = extractor(wsa)
            if detail_data:
                details = ''.join(f'<li>{detail}</li>' for detail in detail_data)
                from dtk.html import popover, glyph_icon
                icon = glyph_icon('info-sign')
                details = popover(icon, details)
            else:
                details = ''

            if self.ScoreClass.weight != 0:
                input_el = f'''
                    <input name="score_{wsa.id}_{self.scoretype}"
                        step="0.1"
                        class="score"
                        type="number"
                        placeholder="Score" value="{score}"/>
                        '''
            else:
                input_el = ''

            return mark_safe(f'''{input_el}{details}
                <textarea name="note_{wsa.id}_{self.scoretype}"
                        placeholder="Notes/Sources"
                        class="scorenote">{note}</textarea>
                ''')
        return Table.Column(self.name, extract=_extract)



class EditableScoreColumns(ColumnGroup):
    def __init__(self, max_phase_data):
        self.max_phase_data = max_phase_data

    def make_datas(self, wsas):
        if not wsas:
            return [], {}
        ws = wsas[0].ws

        max_phase_data = self.max_phase_data
        from moldata.models import ScoreTypes
        cols = [
            EditableHitScoreValue(ws, ScoreTypes.HITSEL_NOTE),
            EditableHitScoreValue(ws, ScoreTypes.POTENCY),
            EditableHitScoreValue(ws, ScoreTypes.SELECTIVITY),
            EditableHitScoreValue(ws, ScoreTypes.PK),
            EditableHitScoreValue(ws, ScoreTypes.DOSING_ROA, max_phase_data=max_phase_data),
            EditableHitScoreValue(ws, ScoreTypes.PRECLINICAL_NOVELTY),
            EditableHitScoreValue(ws, ScoreTypes.TOLERABILITY, max_phase_data=max_phase_data),
            EditableHitScoreValue(ws, ScoreTypes.COMMERCIAL_AVAILABILITY),
            EditableHitScoreValue(ws, ScoreTypes.INTELLECTUAL_PROPERTY),
            EditableHitScoreValue(ws, ScoreTypes.CHEMISTRY),
            ]

        col_datas = []
        for col in cols:
            extractor = col.make_wsa_extractor(wsas)
            col_datas.append((extractor, col))

        def _extract_overall(wsa):
            overall = 0
            for extractor, col in col_datas:
                note, score, detail_data = extractor(wsa)
                weight = col.ScoreClass.weight
                if score:
                    overall += weight * score
            return overall

        overall_scores = {wsa.id: _extract_overall(wsa) for wsa in wsas}
        return col_datas, overall_scores


    def resolve_to_columns(self, wsas):
        col_datas, overall_scores = self.make_datas(wsas)

        def _extract_overall(wsa):
            overall = overall_scores[wsa.id]
            if overall is None:
                return ''
            else:
                return f'{overall:.2f}'


        table_cols = [
            col.resolve_to_column(extractor)
            for extractor, col in col_datas
            ]

        return [Table.Column("Overall", extract=_extract_overall)] + table_cols



class Name(SingleColumn):
    def __init__(self):
        super().__init__('Name')

    def _extract(self, wsa):
        return mark_safe(f'<a href="{wsa.drug_url()}">{wsa.agent.canonical}</a>')


class Structure(SingleColumn):
    def __init__(self):
        super().__init__('Struct')
    def _extract(self, wsa):
        url = reverse('chem_image', args=[wsa.agent_id])
        return mark_safe(f'<a href="{url}"><img loading="lazy" class="struct" src="{url}"></a>')



class StructureAndCore(SingleColumn):
    def __init__(self, name, dims=None):
        super().__init__(name)
        self.dims = dims
    def _extract_all(self, wsas):
        from collections import defaultdict
        from drugs.models import Blob, Drug
        counter = defaultdict(int)
        wsa_to_core = {}
        version = wsas[0].ws.get_dpi_version()
        agents = [wsa.agent_id for wsa in wsas]
        drug2smiles = Drug.bulk_prop(agents, version=version, prop_name='std_smiles', PropClass=Blob).fwd_map()
        for wsa in wsas:
            from rdkit.Chem.Scaffolds import MurckoScaffold
            from rdkit import Chem
            all_smiles = drug2smiles.get(wsa.agent_id)
            if all_smiles:
                smiles = next(iter(all_smiles))
            else:
                smiles = None
            coresm = ''
            if smiles:
                mol = Chem.MolFromSmiles(smiles)
                if mol:
                    core = MurckoScaffold.GetScaffoldForMol(mol)
                    coresm = Chem.MolToSmiles(core)
            wsa_to_core[wsa.id] = coresm
            counter[coresm] += 1

        for wsa in wsas:
            coresm = wsa_to_core[wsa.id]
            core_cnt = counter[coresm]
            import urllib.parse
            urlcoresm = urllib.parse.quote(coresm)
            url = reverse('chem_image', args=[wsa.agent_id]) + f'?align={urlcoresm}&core=true'
            if self.dims:
                url += f'&width={self.dims[0]}&height={self.dims[1]}'

            if counter[coresm] > 1 and coresm:
                coremsg = f'<corecount>{counter[coresm]} with core</corecount>'
            else:
                coremsg = ''
            yield wsa.id, mark_safe(f'''
                <core>{coresm}</core>
                <a target='_blank' href="{url}">
                    <img loading="lazy" class="struct" src="{url}">
                </a> {coremsg}
                ''')

class Indication(SingleColumn):
    def __init__(self):
        super().__init__('Indication')
    def _extract(self, wsa):
        return wsa.indication_link()


class CommAvail(ColumnGroup):
    def resolve_to_columns(self, wsas):
        from dtk.selectability import AvailabilityFeatureSet
        avail = AvailabilityFeatureSet()
        ws = wsas[0].ws
        is_avail = avail.make_mat(ws, wsas)
        wsa_to_idx = {wsa:idx for idx, wsa in enumerate(wsas)}

        def extract(wsa):
            return 'Yes' if is_avail[wsa_to_idx[wsa]][0] else 'Unknown'

        return [Table.Column("CommAvail", extract=extract)]

class DpiSim(ColumnGroup):
    def __init__(self, ref_wsa_id, ref_prots=None, dpi=None):
        if ref_wsa_id:
            from browse.models import WsAnnotation
            self.ref_wsa = WsAnnotation.objects.get(pk=ref_wsa_id)
        else:
            self.ref_wsa = None

        self.ref_prots = set(ref_prots) if ref_prots else set()
        self.dpi = dpi

    def resolve_to_columns(self, wsas):
        if not self.ref_wsa:
            self.ref_wsa = wsas[0]

        if self.ref_wsa not in wsas:
            wsas = list(wsas) + [self.ref_wsa]

        from dtk.prot_map import AgentTargetCache
        ws = wsas[0].ws
        atc = AgentTargetCache.atc_for_wsas(wsas=wsas, ws=ws, dpi_mapping=self.dpi)

        from collections import defaultdict
        wsa_prot_binding = defaultdict(dict)

        for wsa in wsas:
            for key, prot, gene, ev, dr in atc.full_info_for_agent(wsa.agent_id):
                wsa_prot_binding[wsa.id][prot] = (ev, dr)

        from dtk.similarity import calc_jaccard
        def extract(wsa):
            p1 = wsa_prot_binding[wsa.id].keys()
            p2 = self.ref_prots or wsa_prot_binding[self.ref_wsa.id].keys()
            return '%.3f' % calc_jaccard(p1, p2)

        return [Table.Column("Dpi Simil", extract=extract)]


class MaxPhase(ColumnGroup):
    def __init__(self, max_phase_data=None):
        self._max_phase_data = max_phase_data

    def resolve_to_columns(self, wsas):
        if not self._max_phase_data:
            from browse.models import WsAnnotation
            self._max_phase_data = WsAnnotation.bulk_max_phase(wsas)

        def extract(wsa):
            max_phase = self._max_phase_data[wsa.id]['overall_max_phase']

            if max_phase == 4:
                term = 'Approved'
            elif max_phase == 0:
                term = 'Experimental'
            else:
                term = f'Ph.{max_phase}'
            term = f'{max_phase} ({term})'
            return term
        return [Table.Column("Max Phase", extract=extract)]


class Dpi(ColumnGroup):
    def __init__(self, ref_wsa_id=None, ref_prots=None, other_col_filter=None, dpi=None):
        """
        ref_wsa_id or ref_prots indicate the columns to highlight.
        other_col_filter can be used to cull sparse DPIs into a single Other column
        """
        self.ref_wsa_id = ref_wsa_id
        self.ref_prots = ref_prots or set()
        self.other_col_filter = other_col_filter or (lambda *x: False)
        self.dpi = dpi

    def resolve_to_columns(self, wsas):
        from dtk.prot_map import AgentTargetCache
        ws = wsas[0].ws
        atc = AgentTargetCache.atc_for_wsas(wsas=wsas, ws=ws, dpi_mapping=self.dpi)

        from dtk.plot import dpi_arrow
        def binding_arrow(uniprot, gene, ev, dr):
            return dpi_arrow(dr)

        from collections import defaultdict
        prot_wsa_binding = defaultdict(dict)

        for wsa in wsas:
            for key, prot, gene, ev, dr in atc.full_info_for_agent(wsa.agent_id):
                prot_wsa_binding[prot][wsa.id] = binding_arrow(prot, gene, ev, dr)

        def prot_in_ref(prot):
            return self.ref_wsa_id in prot_wsa_binding[prot] or prot in self.ref_prots
        def make_col(prot):
            gene = atc.prot2gene.get(prot, prot)
            binding = prot_wsa_binding[prot]
            def extract(x):
                return binding.get(x.id, '')
            from dtk.html import link
            gene_url = ws.reverse('protein', prot)
            in_ref = prot_in_ref(prot)

            cnt = len(binding)

            header = link(mark_safe(f'{gene}&nbsp;({cnt})'), gene_url)

            if in_ref:
                header = mark_safe(f"<span class='ref-prots'>{header}</span>")

            return Table.Column(header, extract=extract)

        def order(prot):
            in_ref = prot_in_ref(prot)
            cnt = len(prot_wsa_binding[prot])
            alpha = atc.prot2gene.get(prot, prot)
            return (not in_ref, -cnt, alpha)

        all_prots = sorted(atc.all_prots, key=order)
        other_prots = {prot for idx, prot in enumerate(all_prots)
                       if self.other_col_filter(prot_in_ref(prot), idx, len(prot_wsa_binding[prot]))}

        out = [make_col(prot) for prot in all_prots if prot not in other_prots]

        def extract_others(x):
            others = []
            for prot in sorted(other_prots, key=lambda x: atc.prot2gene.get(x, x)):
                if x.id in prot_wsa_binding[prot]:
                    arrow = prot_wsa_binding[prot][x.id]
                    from dtk.html import link
                    gene_url = ws.reverse('protein', prot)
                    gene = atc.prot2gene.get(prot, prot)
                    gene_link = link(mark_safe(f'{gene}{arrow}'), gene_url, extra_attrs={'class': 'dpi'})
                    others.append(gene_link)

            return mark_safe(' '.join(others))


        if other_prots:
            out.append(Table.Column('Other', extract=extract_others))
        return out

class DpiColumn(ColumnGroup):
    def resolve_to_columns(self, wsas):
        from dtk.prot_map import AgentTargetCache
        ws = wsas[0].ws
        atc = AgentTargetCache.atc_for_wsas(wsas=wsas, ws=ws)

        from dtk.plot import dpi_arrow
        from dtk.html import link
        def binding_arrow(uniprot, gene, ev, dr):
            gene_url = ws.reverse('protein', uniprot)
            out = link(mark_safe(f'{gene}{dpi_arrow(dr)}'), gene_url, extra_attrs={'class': 'dpi'})
            return out

        def _extract(wsa):
            out = []
            for key, prot, gene, ev, dr in atc.full_info_for_agent(wsa.agent_id):
                out.append(binding_arrow(prot, gene, ev, dr))
            return mark_safe(''.join(out))

        return [Table.Column('DPI', extract=_extract)]


def resolve_cols(col_groups, rows):
    out = []
    if not rows:
        return out
    from dtk.table import Table
    for group in col_groups:
        if isinstance(group, Table.Column):
            out.append(group)
        else:
            out.extend(group.resolve_to_columns(rows))
    return out

class EffRankColumn(SingleColumn):
    def __init__(self):
        super().__init__('Best Eff Rank')

    def _extract_all(self, wsas):
        from browse.models import Prescreen
        from runner.process_info import JobInfo
        from dtk.scores import Ranker
        ws = wsas[0].ws
        psqs = Prescreen.objects.filter(ws=ws)
        def get_ranker(ps):
            bji = JobInfo.get_bound(ws,ps.eff_jid())
            cat = bji.get_data_catalog()
            return Ranker(cat.get_ordering(ps.eff_code(),True))

        rankers = [get_ranker(ps) for ps in psqs]
        for wsa in wsas:
            ranks = [ranker.get(wsa.id) for ranker in rankers]
            yield wsa.id, min(ranks) if ranks else None

class ReviewedInWs(SingleColumn):
    def __init__(self):
        super().__init__('Reviewed in WS')

    def _extract_all(self, wsas):

        version = wsas[0].ws.get_dpi_version()
        from drugs.models import Drug
        from browse.models import WsAnnotation, DispositionAudit
        from dtk.data import MultiMap
        w2a = {wsa.id:wsa.agent_id for wsa in wsas}
        a2a = Drug.matched_id_mm(w2a.values(), version=version)

        all_wsas = WsAnnotation.objects.filter(agent__in=a2a.rev_map().keys())
        a2allwsa = MultiMap((wsa.agent_id, wsa) for wsa in all_wsas).fwd_map()

        iv = WsAnnotation.indication_vals
        useful_inds = set(WsAnnotation.discovery_order) - {iv.UNCLASSIFIED, iv.INITIAL_PREDICTION}

        all_das = DispositionAudit.objects.filter(wsa__in=all_wsas, indication__in=useful_inds)
        wsa2inds = MultiMap((da.wsa_id, da.indication) for da in all_das).fwd_map()

        from django.utils.safestring import mark_safe
        from dtk.html import link
        import functools

        # This involves a db lookup each time, just cache by ws.
        @functools.lru_cache()
        def get_short_name(ws):
            return ws.get_short_name()

        for wsa in wsas:
            entry = []
            all_agents = a2a.fwd_map().get(wsa.agent_id, [])
            for agentid in all_agents:
                for linkedwsa in a2allwsa.get(agentid, []):
                    if linkedwsa.id in wsa2inds:
                        entry.append(linkedwsa)
            entry.sort(key=lambda x: get_short_name(x.ws))
            entry = [link(get_short_name(x.ws), x.drug_url()) for x in entry]
            yield wsa.id, mark_safe('<br>'.join(entry))


class DeleteColumn(SingleColumn):
    def __init__(self):
        super().__init__('X')
    def _extract(self, wsa):
        """
        Note that this only creates the button element, you will need some JS to do the action.  We could
        put a form in here, but if your table is already inside a form, that won't work.
        """
        return mark_safe(f'''
                    <button type='button'
                            id='delwsa'
                            wsaid='{wsa.id}'
                            class="btn btn-default glyphicon glyphicon-trash"
                            >
                    </button>
                ''')
